
int timer5_count_encoder = 0;    // Счетчик для сброса энкодера и расчета скорости вращения
int timer5_count_servo_1 = 0;    // Счетчик для подсчета времени между сигналами на поворот
int timer5_count_line_1 = 0;    // Счетчик для подсчета времени между считываниеми линии
int timer5_count_magnetrom_1 = 0;    // Счетчик для подсчета времени между считываниями магнетрометра
int timer5_count_datatime = 0;    // Счетчик для подсчета времени между считываниями часов
int timer5_count_BME280 = 0;    // Счетчик для подсчета времени между считываниями температуры
int timer5_count_seconds = 0;    // Счетчик для подсчета секунд с начала запуска
int timer5_count_Gy56 = 0;    // Счетчик для подсчета времени между измерениями
int timer5_count_arduino_slave = 0;    // Счетчик для подсчета времени между передачами в вторую ардуино
int timer5_count_print = 0;    // Счетчик для подсчета времени между печатью в порт через блютуз
int timer5_line = 0;    // Счетчик для подсчета времени между считыванием датчика линии








static void Timer5_Init()     // Таймер 5 на 10 милисекунд по совпадению А
{
	TCCR5A = 0;
	TCCR5B = 0;
	TCCR5B |= (1 << WGM52);                    // Режим CTC (сброс по совпадению) 
   // TCCR5B |= (1<<CS50);                       // Тактирование от CLK. 
															  // Если нужен предделитель : 
	// TCCR5B |= (1<<CS51);                   // CLK/8 
	TCCR5B |= (1 << CS50) | (1 << CS51); // CLK/64 //          Через 4 микросекунды считает 1/(16 000 000/64)
   // TCCR5B |= (1<<CS52);                   // CLK/256 
   // TCCR5B |= (1<<CS50)|(1<<CS52); // CLK/1024 
															// Верхняя граница счета. Диапазон от 0 до 65535. 
	OCR5A = 2499;    // Умножить на 4 микросекунды                         // Частота прерываний A будет = Fclk/(N*(1+OCR5A))  На 1 меньше так как считает от 0
  //  OCR5B = 15624;                                // Частота прерываний B будет = Fclk/(N*(1+OCR5B)) 
															 // где N - коэф. предделителя (1, 8, 64, 256 или 1024) 
	TIMSK5 = (1 << OCIE5A);                   // Разрешить прерывание по совпадению A 
   // TIMSK5 |= (1<<OCIE5B);                   // Разрешить прерывание по совпадению B 
  //  TIMSK5 |= (1<<TOIE5);                     // Разрешить прерывание по переполнению 
}



ISR(TIMER5_COMPA_vect)         // Обработчик прерывания таймера 4 по совпадению A 	1 раз в 10 милисекунд
{
	digitalWrite(42, 1);
	//Serial.print(".");

	flag_BNO055 = true;        // Взыодим флаг что можно считывать данные из датчика

		//==========================================================	Таймер на Энкодеры для считывания значений и вычисления скорости вращения
	timer5_count_encoder++;	
	if (timer5_count_encoder >= 1)        // 10 milliseconds
	{
		timer5_count_encoder = 0;
		flag_Encoder = true;
		flag_PWM = true;
	}
	//==========================================================   Таймер на серво моторы время между поворотами на следующий угол
	timer5_count_servo_1++;
	timer5_count_Gy56++;            //

	if (timer5_count_servo_1 >= 8)       // 80 milliseconds
	{
		timer5_count_servo_1 = 0;
		timer5_count_Gy56 = 0;		   // Сбрасываем счетчик именно тут чтобы синхронизировать по моменту измерений
		flag_servo = true;
	}
	if (timer5_count_Gy56 == 1)          //Если прошлоо 10 милисекунд это время достаточное для поворота на 5 градусов
	{
		flag_Gy56_Start = true;             
	}
	if (timer5_count_Gy56 == 7)          //Если прошлоо 70 милисекунд это время достаточное для измерения
	{
		flag_Gy56_End = true;
		//Serial.println("U");
	}

	//==========================================================	Таймер на считывания датчиков линии
	timer5_count_line_1++;
	if (timer5_count_line_1 >= 25)       // 250 milliseconds
	{
		timer5_count_line_1 = 0;
		flag_line = true;              // Взводим флаг что-бы потом в основном цикле считать значения
	}
	//==========================================================	Таймер на опрос магентрометра

	timer5_count_magnetrom_1++;
	if (timer5_count_magnetrom_1 == 1)       // 20 milliseconds		По даташиду максимальная частота 100Герц  
	{
		timer5_count_magnetrom_1 = 0;
		flag_magnetrom = true;              // Взводим флаг что-бы потом в основном цикле считать значения
	}
	//==========================================================	 Таймер на опрос часов
	timer5_count_datatime++;
	if (timer5_count_datatime >= 50)       // 500 milliseconds	0.5 секунд	
	{
		timer5_count_datatime = 0;
		flag_datatime = true;              // Взводим флаг что-бы потом в основном цикле считать значения
	}
	//==========================================================	 Таймер на опрос температуры
	timer5_count_BME280++;
	if (timer5_count_BME280 >= 100)       // 1000 milliseconds	1.0 секунд	
	{
		timer5_count_BME280 = 0;
		flag_BME280 = true;              // Взводим флаг что-бы потом в основном цикле считать значения
	}

	//==========================================================	 Таймер на передачу во вторую ардуино
	timer5_count_arduino_slave++;
	if (timer5_count_arduino_slave == 25)       // 250 milliseconds	0.2 секунд	
	{
		timer5_count_arduino_slave = 0;
		flag_Arduino_Slave = true;              // Взводим флаг что-бы потом в основном цикле обработать

	}
	//==========================================================	 Таймер на печать через блютуз
	timer5_count_print++;
	if (timer5_count_print == 10)       // 100 milliseconds	0.1 секунд	
	{
		timer5_count_print = 0;
		flag_print = true;             // Взводим флаг что-бы потом в основном цикле обработать
	}

	//==========================================================	 Таймер на отсчет секунд с начала работы
	timer5_count_seconds++;
	if (timer5_count_seconds >= 100)        // 1000 milliseconds
	{
		timer5_count_seconds = 0;
		second++;
	}
	//==========================================================	 Таймер на считыввание датчика линии  и Датчиков сверху
	timer5_line++;
	if (timer5_line >= 12)        // 120 milliseconds
	{
		timer5_line = 0;
		flag_Line = true;
		flag_VL53L0X = true;

	}


	//==========================================================	Таймер на Энкодеры для считывания значений и вычисления скорости вращения


	//digitalWrite(14, 1);
	//digitalWrite(14, 0);
	//PORTJ = 0b00000000;

	//PORTJ |= (1 << 1);

	//PORTJ &= ~(1 << 1);
	digitalWrite(42, 0);

}
